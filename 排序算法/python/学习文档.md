## leetcode刷题时补充知识

```python
海象运算符 :=
a=["Jack!","hello","world"]
a_lens=[l for s in a if (l := len(s)) > 4]

替代条件运算符
a=True
b="T" if a else "F"

collections包
# 计算出现的次数
a=[1,1,3,2,2,4]
cnt=collections.Counter(a)

# 默认字典，即 随便一个键应该返回的值的类型
mp=collections.defaultdict(list)
mp[3]	# 默认返回列表，这里由于没有键值3，所以返回空列表

# 堆
a=[1,3,5,1,6]
heapq.heapify(a) # 堆化；使列表a具有堆得特征

# 等价于
b=[]
for v in a:
    heapq.heappush(b,v)
heapq.nlargest(b,2)
	# [6,5]
heapq.nsmallest(b,2)
	# [1,2]
    
heapq.heappop(b)
	# 1
len(b)
	# 4
    
heapq.heapreplace(b,2) # 等价于 先pop 再push 2
	# 1
len(b)
	# 4 



```





## 小结

不可变对象实际意义

```python
a="abcd"
b="abcd"

c=(1,2)
d=(1,2)
print(id(a),id(b)) # 140711818535216 140711818535216
print(id(c),id(d)) # 140711819409536 140711819409536
```





python是链式存储，而非顺序存储

```python
ls=[1,2,3,4]
for i in ls:
    print(id(i))
    # 94717610930656 # 寻址空间 并不是顺序
    # 94717610930688
    # 94717610930720
    # 94717610930752
ls[1]=5
for i in ls:
    print(id(i))
    # 94717610930656
    # 94717610930784 #只有这个变了
    # 94717610930720
    # 94717610930752
```





false值

```python
None
""
()
[]
set()
{}
```





逻辑运算符

**python没有自增或自自减运算符**

**pass命令：占位符，由于python不允许空语句块，防止报错**

```python
not
and
or

# 可以采用以下方式判断数字区间
if 1<a<8:
    pass

# 错误示范
a=1
a++
```





**元组的自动装包与拆包**

​	函数多返回值

​	多变量赋值





之所以在Python中不使用()或{}包裹代码：原因在于()指元组，{}指字典或集合，都已经被使用表示为数据结构





**python只存在if条件,没有switch**

如果 if 语句中的条件过长，可以用接续符 \ 来换行。

```python
if 2>1 and 3>2 and 4>3 and \
    5>4 and 6>5 and 7>6 and \
    8>7:
    print("OK")
```





**python只存在两种循环，while或for...in循环,这两种循环都有else子结构，用来在循环正常退出后执行（非break退出)**

**range方法**

```python
# range方法 => 生成列表
list(range(5))
[0, 1, 2, 3, 4]

```



**python不支持字符串与数字的自动连接**

```python
print(1+"1")
# TypeError: unsupported operand type(s) for +: 'int' and 'str'
```



批量赋值

```python
a,b,c="abc"
a,b,c=[1,2,3]
a,b,c=(1,2,3)
```







### 格式化字符串

```python
print( "{0}  ({1})".format(x,type(x)) )
print("{:.2f}".format(3.1415926))

print(format(x,"%.2f"))

print(f"{(j+1):2d}  {c[j]}")
print("%d-%d" % (1,2))
```



```python
>>>"{} {}".format("hello", "world")    # 不设置指定位置，按默认顺序
'hello world'
 
>>> "{0} {1}".format("hello", "world")  # 设置指定位置
'hello world'
 
>>> "{1} {0} {1}".format("hello", "world")  # 设置指定位置
'world hello world'


print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com"))
 
# 通过字典设置参数
site = {"name": "菜鸟教程", "url": "www.runoob.com"}
print("网站名：{name}, 地址 {url}".format(**site))

# 元组的 format 用法
k=("name","mh")
v="名字：{0},name:{1}".format(*k)
print(v)
 
# 通过列表索引设置参数
my_list = ['菜鸟教程', 'www.runoob.com']
print("网站名：{0[0]}, 地址 {0[1]}".format(my_list))  # "0" 是必须的

# 传入对象
print('value 为: {0.value}'.format(my_value))  # "0" 是可选的
```



| 数字       | 格式                                                         | 输出                   | 描述                         |
| :--------- | :----------------------------------------------------------- | :--------------------- | :--------------------------- |
| 3.1415926  | {:.2f}                                                       | 3.14                   | 保留小数点后两位             |
| 3.1415926  | {:+.2f}                                                      | +3.14                  | 带符号保留小数点后两位       |
| -1         | {:+.2f}                                                      | -1.00                  | 带符号保留小数点后两位       |
| 2.71828    | {:.0f}                                                       | 3                      | 不带小数                     |
| 5          | {:0>2d}                                                      | 05                     | 数字补零 (填充左边, 宽度为2) |
| 5          | {:x<4d}                                                      | 5xxx                   | 数字补x (填充右边, 宽度为4)  |
| 10         | {:x<4d}                                                      | 10xx                   | 数字补x (填充右边, 宽度为4)  |
| 1000000    | {:,}                                                         | 1,000,000              | 以逗号分隔的数字格式         |
| 0.25       | {:.2%}                                                       | 25.00%                 | 百分比格式                   |
| 1000000000 | {:.2e}                                                       | 1.00e+09               | 指数记法                     |
| 13         | {:>10d}                                                      | 13                     | 右对齐 (默认, 宽度为10)      |
| 13         | {:<10d}                                                      | 13                     | 左对齐 (宽度为10)            |
| 13         | {:^10d}                                                      | 13                     | 中间对齐 (宽度为10)          |
| 11         | `'{:b}'.format(11) '{:d}'.format(11) '{:o}'.format(11) '{:x}'.format(11) '{:#x}'.format(11) '{:#X}'.format(11)` | `1011 11 13 b 0xb 0XB` | 进制                         |





### 动态倒入模块

```python
def foo():
	global re
	re=__import__("re")
foo()	
pattern=re.compile(r"\d+")
print(int("123"))
res=pattern.sub(lambda x:str(int(x.group())*2),"ab12cd34")
print("res=",res)
```







### 全局方法

```python
dict
set
	# 进行关系测试，删除重复数据，还可以计算交集、差集、并集等
	# 由于set中的元素必须是不可变类型；而普通集合（set）本身是可变的，那么它的实例就不能放在另一个集合中
    frozenset
    	# 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素
list
	# 将元组或字符串转换为列表
int
	# int(x,base)
    # 若 x 为纯数字，则不能有 base 参数，否则报错；其作用为对入参 x 取整
    # 若 x 为 str,此时str须为整数，则 base 可略可有。base 存在时，视 x 为 base 类型数字，并将其转换为 10 进制数字
    bool
    	# 将给定参数转换为布尔类型，如果没有参数，返回 False
    float
    	# 将整数和字符串转换成浮点数
    complex
str
	# 将对象转化为适于人阅读的形式
tuple
	# 可迭代系列（如列表）转换为元组
    # 可以将字符串，列表，字典(只保留键值），集合转化为元组


isinstance
	# 额外注意  isinstance (1,(str,int,list))    # 是元组中的一个返回 True
issubclass
type
	# 如果你只有第一个参数则返回对象的类型，三个参数返回 新的类型对象(类本身，生成类)
super
classmethod
staticmethod


bin
oct
hex
sum
	# sum(iterable[, start])
    # 指定相加的参数，如果没有设置这个值，默认为0
abs
min
max
	# max(*[1,2,3],*[4,5,3])
divmod
	# 返回一个包含商和余数的元组(a // b, a % b)
round
	# 由于浮点数不一定能精确表达，并不一定按照四舍五入的规则来计算



range
len
	# 是内置函数，返回对象的长度（元素个数）
    # 不是字符串类的方法
slice
	# slice(stop);slice(start, stop[, step])
	#用在切片操作函数里的参数传递
    	# a=(1,2,3,4,5)[slice(2)] # 结果:(1,2)
        # b=range(10)[slice(5)]		# 结果:range(5)
filter
	# 用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换
    # list(filter((lambda x : x%2==1),range(10)))
map
	# list(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))
reduce
	# 已经被从全局名字空间里移除了，它现在被放置在 functools 模块里
	# from functools import reduce
    # functools.reduce(lambda x,y:y+x,'Hello')	# # 输出 olleH
sorted
	# sorted(iterable, key=None, reverse=False)  
	# sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作
    # list 的 sort 方法返回的是对已经存在的列表进行操作
    # 内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。
reversed
	# 返回一个反转的迭代器
    #  要转换的序列，可以是 tuple, string, list 或 range
    # list(reversed(range(5)))
enumerate
	# 用于将 一个序列、迭代器或其他支持迭代对象 组合为一个索引序列，同时列出数据下标 和 数据
zip
	# list(zip(a,b))  # [(1, 4), (2, 5), (3, 6)]
    # a1, a2 = zip(*zip(a,b)) # [(1,2,3),(4,5,6)]
iter
next
	# next(iterable[, default])
    # default -- 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常
    
    
print
	# print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
    # flush -- 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新
    # flush为False时，是缓存所有输出到终端的字符（即使使用time.sleep暂时休眠，也会等到当前程序执行完毕后，最后一起显示）963圣
input
	# 返回为 string 类型
    # input() 函数的参数只能为单个字符串
repr
ascii



del
all
	# 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False
	# all([]) == True , all(()) == True
    # all([[]]) == False
any
	# 判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True
    
    
    
    
callable
	# 判断一个对象能否被调用
    # 如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功
    # 对于函数、方法、lambda 函式、 类以及实现了 __call__ 方法的类实例, 它都返回 True。
getattr(object, name[, default])
	# 如果指定的属性不存在，则返回default的值，若没有设置default参数，则抛出AttributeError异常
setattr(object, name, value)
	# 用于设置指定属性的值，若指定的属性不存在则新建属性并赋值
delattr(object, name)  
    # delattr( )函数用于删除属性,若属性不存在则抛出 AttributeError 异常
hasattr(o,name)
property
	# 类似js存储器属性


__import__
	# 函数用于动态加载类和函数,如果一个模块经常变化就可以使用 __import__() 来动态载入
ord
	# 以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值
chr
	# ord逆运算
eval
exec
compile
	# 将一个字符串编译为字节代码
    # exec(compile(str,'','exec'))
    # eval(compile(str,'','eval'))
id
	# 用于获取对象的内存地址
hash
	# hash() 函数可以应用于数字、字符串和对象，不能直接应用于 list、set、dictionary
    # 在 hash() 对对象使用时，所得的结果和对象的内容无关，只和对象的 id()，也就是内存地址有关
    # 实际上针对数字，字符串，元组等不可变类型，内容相同id一定相同
help("")


globals
	# 以字典类型返回 全部全局变量,可以在函数内部通过该方法的返回值 直接修改 全局的同名属性
vars
	# 字典
	# 返回对象object的属性和属性值的字典对象，如果没有参数，就打印当前调用位置的属性和属性值 
locals
	# 等价于vars
dir(obj)
	# 列表
	# dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；
    # 带参数时，返回参数的属性、方法列表。
    # 如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。


```





#### sorted

```python
# 利用key进行倒序排序
example_list = [5, 0, 6, 1, 2, 7, 3, 4]
result_list = sorted(example_list, key=lambda x: x*-1)



# 先按照成绩降序排序，相同成绩的按照名字升序排序：
d1 = [{'name':'alice', 'score':38}, {'name':'bob', 'score':18}, {'name':'darl', 'score':28}, {'name':'christ', 'score':28}]
l = sorted(d1, key=lambda x:(-x['score'], x['name']))
print(l)



# 对奖牌榜就行排序，数据里面包含了15个国家的金、银、铜数据，使用 \n 作为分隔符
s = "德国 10 11 16\n意大利 10 10 20\n荷兰 10 12 14\n法国 10 12 11\n英国 22 21 22\n中国 38 32 18\n日本 27 14 17\n美国 39 41 33\n俄罗斯奥委会 20 28 23\n澳大利亚 17 7 22\n匈牙利 6 7 7\n加拿大 7 6 11\n古巴 7 3 5\n巴西 7 6 8\n新西兰 7 6 7"
stodata = s.split('\n',-1)

# 使用sorted
para = {}

for line in range(len(stodata)):
    # 每一行数据
    data = stodata[line].split(' ')
    print(data)
    # 组装数据结构para={'China': [], 'Russia': []}
    para[data[0]] = [int('-' + i) for i in data[1:]]
# 开始排序(x[1]代表奖牌数目, x[0]代表国家)
new_para = sorted(para.items(), key=lambda x: (x[1], x[0]))
print()

c=[]
for i in new_para:
     c.append((i[0]))
for j in range(15):
    print(f"{(j+1):2d}  {c[j]}")
```





#### enumerate

```python
seasons = ['Spring', 'Summer', 'Fall', 'Winter']
list(enumerate(seasons))
# [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]

list(enumerate(seasons, start=1))       # 小标从 1 开始
# [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```





#### input

```python
for i in range(2):
    	lis.append(int(input(f'你想输入的第{i+1}个数字是？')))
        
        
# ======================================================
        
#输入三角形的三边长
a,b,c = (input("请输入三角形三边的长：").split())
a= int(a)
b= int(b)
c= int(c)

#计算三角形的半周长p
p=(a+b+c)/2

#计算三角形的面积s
s=(p*(p-a)*(p-b)*(p-c))**0.5

#输出三角形的面积
print("三角形面积为：",format(s,'.2f'))
```







#### eval | exec

```python
#语法
	eval(expression[, globals[, locals]])
	exec(object[, globals[, locals]])
# globals -- 变量作用域，全局命名空间
	# locals -- 变量作用域，局部命名空间
	# 也就是：eval中的字符串表达式，执行时所生成的的作用域
    
eval(s)
	# 引用的是全局环境，执行后影响的是 全局环境；
    	# 若执行时，在全局环境中找不到引用的变量将会报NameError
        # 注意，s中声明的变量 将会映射到全局环境中
eval(s,{},l)
	# 引用的是局部环境，执行后影响的是 局部环境；
    	# 若执行时，在局部环境中找不到引用的变量将会报NameError
        # 注意：s中声明的变量将会输出到 字典l 中以键值对的形式
eval(s,g,l)
	# 引用变量时：先在 局部环境l 中引用，若不存在则会在 暴露的全局环境 g中引用，若还找不到则报错
    # 赋值时：生成的变量在 局部环境l中，除非使用global
```



```python
path=eavl(input("请输入要被执行的命令："))
>>> __import__("os").getcwd() # 输入的命令
# 返回结果：path 将是当前文件夹路径


a,b=eval(input("请输入参数，以','分割':"))
# 输入：10,5，得到 a=10，b=5。



# =============================


x = 10
expr = """
z = 30
sum = x + y + z
print(sum)
"""
def func():
    y = 20
    exec(expr) # x=10 y=20 z=30
    exec(expr, {'x': 1, 'y': 2})	# x=1 y=2 z=30
    exec(expr, {'x': 1, 'y': 2}, {'y': 3, 'z': 4}) # x=1 y=3 z=30
    
func()
# res:
"""
60
33
34
"""
```







#### property

```python
# class property([fget[, fset[, fdel[, doc]]]])
'''
fget -- 获取属性值的函数
fset -- 设置属性值的函数
fdel -- 删除属性值函数
doc -- 属性描述信息
'''

class C(object):
    def __init__(self):
        self._x = None
 
    def getx(self):
        return self._x
 
    def setx(self, value):
        self._x = value
 
    def delx(self):
        del self._x
 
    x = property(getx, setx, delx, "I'm the 'x' property.")
# 如果 c 是 C 的实例化,
'''
c.x 将触发 getter
c.x = value 将触发 setter 
del c.x 触发 deleter

如果给定 doc 参数，其将成为这个属性值的 docstring，否则 property 函数就会复制 fget 函数的 docstring（如果有的话）
'''


# ====================================
# 创建只读属性
class Parrot(object):
    def __init__(self):
        self._voltage = 100000
 
    @property # property做装饰器
    def voltage(self):
        """Get the current voltage."""
        return self._voltage
    
    
# ====================================
# property 的 getter,setter 和 deleter 方法同样可以用作装饰器
'''
这里唯一想不通时 x重复声明了三次，难道不覆盖？
'''
class C(object):
    def __init__(self):
        self._x = None
 
    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x
 
    @x.setter
    def x(self, value):
        self._x = value
 
    @x.deleter
    def x(self):
        del self._x
```









### 特殊变量与属性

```python
# 具体可查看 类与对象 关于重载方法一章
__name__
	当前正在执行时："__main__"
    # 在自己用时就是 __main__，当自己作为模块被调用时就是自己的文件名
__class__

__file__
__loader__
__cached__
__builtins

```





## 数字

### 随机

```python
import random
choice
randrange
randint
uniform

random
seed
shuffle
sample
```





## 字符串

```python
count(str, beg=0, end=len(string))
find
rfind
	# 返回字符串最后一次出现的位置，如果没有匹配项则返回-1
index
	# 如果str不在字符串中会报一个异常
rindex
   
join
	# 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串
split(str="", num=string.count(str))
	# str -- 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。
	# num -- 分割次数。默认为 -1, 即分隔所有。
    
maketrans(src,dst,del)
translate
    '''
    intab = "aeiou"
    outtab = "12345"
    trantab = str.maketrans(intab, outtab)

    str = "this is string example....wow!!!"
    print (str.translate(trantab))
    '''
replace(old, new [, max])

center(width[, fillchar])
rjust
ljust
zfill
	# 等价于rjust(fillchar='0')

strip([chars])
	# 默认参数[' ']，等价于trim
lstrip
rstrip

endswith
startswith

capitalize
title
upper
lower
swapcase

	# is系列
    
isdigit
isnumerical
isdecimal

```







## 元组

```python
# 创建空元组
	tup1 = ()
    
# 只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用
	tup1 = (50,)
    
# 元素值是不允许修改
# 元素值是不允许删除的，但我们可以使用del语句来删除整个元组


min
max
tuple
len

# 元组的装包与拆包
	元组装包拆包是自动的
    
    a=1,2,3
    #它其实等价于下面的代码
    a=(1,2,3)
    #因为等号左边只有1个变量，而等号右边有3个值，因此自动装包成为一个元组
    


```









## 列表

```python
append
extend
insert

remove(o)
	# 删除列表中值为 x 的第一个元素，从左往右
    # 如果没有这样的元素，就会返回一个错误
pop(index=-1)
	# 默认弹出 最后一个元素
clear

copy
sort( key=None, reverse=False)
	# 会改变list
    # sort(key=len)
reverse


count(o)
index(x[, start[, end]])

# ===================================
# n 创建二维列表
[[0 for col in range(cols)] for row in range(rows)]

# 填充列表
list_empty = [0]*10
list_empty = [None]*10


# [:-1] 和 [::-1]

'''
# 列表推导式
[表达式 for 变量 in 列表]
或者
[表达式 for 变量 in 列表 if 条件]
'''

# =================================
# Python 列表是链式存储结构，并非顺序存储
a=[1,2,3,4]
for i in range(len(a)):
    print(id(a[i]))
a[1]=100
print("----------")
for i in range(len(a)):
    print(id(a[i]))
    
    
    
a=['delphi', 'Delphi', 'python', 'Python', 'golang', 'Golang', 'c++', 'C++', 'c', 'C']
print(a)
#按字典序升序排序
a.sort() 
print(a)
#先按字符串长度升序排序，长度相同按字典序升序排序
a.sort(key=lambda x:(len(x),x)) 
print(a)
#先按字符串长度升序排序，长度相同按字典序降序排序
a.sort(key=lambda x:(len(x),list(map(lambda c:-ord(c),x)))) 
print(a)
#先按字符串长度降序排序，长度相同按字典序升序排序
a.sort(key=lambda x:(-len(x),x))
print(a)
```







## 集合

```python
# 创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典
# 集合中存放的对象，必须是不可变对象，即：int/str/tuple，不能存放被嵌套的集合/字典/列表/以及特定的类所实例化的对象
# 无序的不重复元素
	怎么判断一个元素是否重复呢？ __hash__/__eq__
# =================================
-
	difference
    difference_update
    	# 改变集合
|
	union
    	# 不会改变 原集合
&
	intersection
    intersection_update
^
	symmetic_difference
    symmetic_difference_update
add
update


remove(o)
	# 如果元素不存在，则会发生错误
discard(o)
	# 相反；如果元素不存在，不会发生错误
pop()
	# 设置随机删除集合中的一个元素
clear()

copy
isdisjoit
	# 不想交
issuperset
	# 包含
issubset
	# 被包含
# =================================
{x for x in 'abracadabra' if x not in 'abc'}

s.update( "字符串" ) 与 s.update( {"字符串"} ) 含义不同:

# 创建一个含有一个元素的集合
my_set = set(('apple',)) # 注意区分 set('apple')
```







## 字典

```python
# 创建字典几种方式
d1={'a':1,'b':2}

d2={}
d2[1]=1
d2['2']='2'

d3=dict(a=1,b=2)

A=['a','b'];
B=[1,2]
d4=dict(zip(A,B))

d5=dict((('a',1),('b',1)))
d6=dict([('a',1),('b',1)])
d7=dict({('a',1),('b',1)})
d8=dict([['a',1],['b',1]])

# 查看字典的数量
len(d)
str(d)

# 键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行


# ================================
fromkeys(seq[, value])
	# 生成指定 键 的字典，其值都为value
'''
seq = ('name', 'age', 'sex')
 
dict = dict.fromkeys(seq)
print ("新的字典为 : %s" %  str(dict)) 		# {'age': None, 'name': None, 'sex': None}
 
dict = dict.fromkeys(seq, 10)
print ("新的字典为 : %s" %  str(dict))		# {'age': 10, 'name': 10, 'sex': 10}
'''


copy
clear

keys
values
items

get(key, default=None)
	# 键不在字典中返回 default 设置的默认值
setdefault(key, default=None)
	# 存在key，不设置,返回对应的值;不存在key，设置，返回设置值
update
	# 把字典参数 dict2 的 key/value(键/值) 对更新到字典 dict 里
pop(key[,default])
	# 如果key存在，则删除该key，并返回其值;若不存在，直接返回默认值
	# 如果要删除的 key 不存在，则需要添加默认值，否则会报错：
popitem
	# 按照 LIFO（Last In First Out 后进先出法） 顺序规则
    # 如果字典已经为空，却调用了此方法，就报出KeyError异常
    # 返回 (key,value) 组成的元组

    
# ==================================

# 字典可以通过以下方法调换 key和 value,当然要注意原始 value 的类型,必须是不可变类型
	reverse = {v: k for k, v in dic.items()}
```







## 

## 小结

### del语句

```python
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]

# 用 del 删除实体变量：
>>> del a
```



### 推导式案列

```python
>>> [str(round(355/113, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']


>>> matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
>>> [[row[i] for row in matrix] for i in range(4)]
[
    [1, 5, 9], 
    [2, 6, 10],
    [3, 7, 11],
    [4, 8, 12]
]


>>> transposed = []
>>> for i in range(4):
...     transposed.append([row[i] for row in matrix])
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]



# ======================================
# 要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：

>>> for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1


# 要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：

>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orang
```







## 函数

```python
# 指定位置参数：顺序输入
# 关键字参数：使用关键字参数允许函数调用时参数的顺序与声明时不一致
# 默认参数
	默认参数必须放在最后面，否则会错
# 不定长参数：加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数
	加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数
	加了两个星号 ** 的参数会以字典的形式导入
        def printinfo( arg1, **vardict ):
           "打印任何传入的参数"
           print ("输出: ")
           print (arg1)
           print (vardict)

        # 调用printinfo 函数
        printinfo(1, a=2,b=3)
        
        # 输出: 
        1
        {'a': 2, 'b': 3}
        
# lambda 函数：匿名函数
	不能访问自己参数列表之外或全局命名空间里的参
    sum = lambda arg1, arg2: arg1 + arg2
    
# 不带参数值的return语句返回None


# 函数也可以以一个函数为其参数:

# 通过 函数名.__doc__ 的方式来显示函数的说明文档


# 指定函数的参数类型和返回值
	这种 “将数据类型写死在代码中” 的行为在集成开发环境/代码编辑器时尤为方便，通过显式地指定函数的参数类型和返回值，能够让智能补全组件提前获知标识符的数据类型，提供有利的辅助开发功能
 def function_demo(param_A: int, param_B: float, param_C: list, param_D: tuple) -> dict:
    pass

```







### 难点

#### 一

声明函数时，参数中星号 ***** 可以单独出现，例如:

```
def f(a,b,*,c):
    return a+b+c
```

如果**单独出现星号 * 后的参数**必须用**关键字**传入。

```python
def f(a,b,*,c):
	return a+b+c

>>> f(1,2,3)   # 报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: f() takes 2 positional arguments but 3 were given
>>> f(1,2,c=3) # 正常
6
>>>
```





#### 二解构调用

```python
print(max(*[1,2,3],*[3,4,5])) # 正常返回 5
```







### 强制位置参数

Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用**指定位置参数**，不能使用关键字参数的形式。

在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参:

```python
def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
```

以下使用方法是正确的:

```python
f(10, 20, 30, d=40, e=50, f=60)
```

以下使用方法会发生错误:

```python
f(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式
f(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式
```





### lambda

lambda 匿名函数也是可以使用"**关键字参数**"进行参数传递

```python
>>> g= lambda x,y : x**2+y**2
>>> g(2,3)
13
>>> g(y=3,x=2)
13
```

同样地，lambda 匿名函数也可以设定默认值

```python
>>> g= lambda x=0,y=0 : x**2+y**2
>>> g(2,3)
13
>>> g(2)
4
>>> g(y=3)
9
```

**注意：如果只打算给其中一部分参数设定默认值，那么应当将其放在靠后的位置（和定义函数时一样，避免歧义），否则会报错。**





### 变量作用域 | ！

![image-20211201193048172](F:\code\Python\imgs\image-20211201193048172.png)

命名空间查找顺序:

假设我们要使用变量 runoob，则 Python 的查找顺序为：**局部的命名空间去 -> 全局命名空间 -> 内置命名空间**。

如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常:

![image-20211201193133971](F:\code\Python\imgs\image-20211201193133971.png)









注意：由于python**不存在声明变量**，因此：块级环境赋值时，相当于声明变量，而不是修改外层同名变量；

```python
a=1;
def chgA():
	a=2; # 赋值，重新声明同名变量
print("a=",a) # a= 1
chgA()
print("a=",a) # a= 1

#=========解决办法============
#提前声明使用的变量为全局变量
a = 10
def sum ( n ) :
   global a
   n += a
   a = 11
   print ('a = ', a, end = ' , ' )
   print ( 'n = ', n )

sum ( 3 )
print ( '外 a = ', a )





#=======================
a = 10
def sum ( n ) :
   n += a # 可以引用全局变量
   print ('a = ', a, end = ' , ' )
   print ( 'n = ', n )
  
sum(3)

#=======================
a = 10
def sum ( n ) :
   n += a # 报错；暂时性死区，局部环境中还未声明的变量 提前使用
   a = 11
   print ('a = ', a, end = ' , ' )
   print ( 'n = ', n )
  
sum(3)
```





#### 重点 | !!!

Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，

其它的代码块（如 if/elif/else/、try/except、for/while等）是**不会**引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：

```python
if True:
    a=10
else:
    a=-1
print("a=",a) #能够正确访问
```











#### nonlocal与global关键字

**nonlocal 只能修改外层函数的变量而不能修改外层函数所引用的全局变量**

```python
x = 0
def outer():
    global x
    x = 1    
    def inner():
        nonlocal x # 报错，只能修改外层函数的变量
        x = 2        
        print(x)
    inner()

outer()
print(x)
```







#### 闭包实现

```python
def Outer():
	a=0
	def inner():
		nonlocal a #声明块级环境使用的a是外层函数的a
		a+=1
		return a
	return inner
closure=Outer()
print("闭包:",closure) # 闭包: <function Outer.<locals>.inner at 0x7f3a975db280>
res=closure()
print("res:",res) # res: 1
res=closure()
print("res:",res) # res: 2
```





```python
def Outer():
	a=0
	def inner():
		a+=1
        # 等价于 a=a+1
        # 报错，原因在于 编译解析阶段 发现：是在块级作用域声明变量a,但又在声明中使用了变量a
        # UnboundLocalError: local variable 'a' referenced before assignment
        # 导致一个 是先有鸡还是先有蛋的 问题
        
        # python 默认对于一个在块级作用域中，赋值一个从未在该块级作用域出现的变量时，是先在该块级声明该变量
		return a
	return inner
```





### 装饰器 | ！



#### 实现

[!文章地址](https://www.runoob.com/w3cnote/python-func-decorators.html)

```python
# 阶段一
函数就是一个功能
	假如存在以下场景：
    	调用函数A的同时又需要调用函数O（也即：完成功能A的同时完成功能O），该怎么办？答案：嵌套函数
        而且这样还有个优点，功能的组合；比如还有一个函数B也需要在调用的时候调用函数O，可以直接复用
        
def use_logging(func):
    logging.warn("%s is running" % func.__name__)
    func()

def foo():
    print('i am foo')

use_logging(foo)

#=================================================
# 阶段二
上述缺点：调用的时候不再是调用真正的业务逻辑 foo 函数，而是换成了 use_logging 函数，这就破坏了原有的代码结构

def use_logging(func):

    def wrapper():
        logging.warn("%s is running" % func.__name__)
        return func()   # 把 foo 当做参数传递进来时，执行func()就相当于执行foo()
    return wrapper

def foo():
    print('i am foo')

foo = use_logging(foo)  # 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于  foo = wrapper
foo()                   # 执行foo()就相当于执行 wrapper()



#=================================
'''
函数进入和退出时 ，被称为一个横切面，这种编程方式被称为面向切面的编程
'''
进入函数A
	进入函数B
    |	进入函数C
    |    	进入函数D
    |        	...
    |       退出函数D
    |   退出函数C
    退出函数B
退出函数A


#==================================
#阶段三

def use_logging(func):

    def wrapper():
        logging.warn("%s is running" % func.__name__)
        return func()
    return wrapper

@use_logging # 真正的装饰器：语法糖
def foo():
    print("i am foo")

foo()
```









#### 传递参数

```python
def wrapper(*args, **kwargs):
        # args是一个数组，kwargs一个字典
        logging.warn("%s is running" % func.__name__)
        return func(*args, **kwargs) # 元组或字典的解构
    return wrapper
```









#### 带参数的装饰器

```python
# 对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包

def use_logging(level):
    def decorator(func):
        def wrapper(*args, **kwargs):
            if level == "warn":
                logging.warn("%s is running" % func.__name__)
            elif level == "info":
                logging.info("%s is running" % func.__name__)
            return func(*args)
        return wrapper

    return decorator

# @use_logging(level="warn") 等价于 @decorator
# 这样就可以访问变量level
@use_logging(level="warn")
def foo(name='foo'):
    print("i am %s" % name)

foo()
```







#### 类装饰器

```python
# 相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的__call__方法
class Foo(object):
    def __init__(self, func):
        self._func = func

    def __call__(self):
        print ('class decorator runing')
        self._func()
        print ('class decorator ending')

@Foo # 类名本身直接接受 函数
def bar():
    print ('bar')

bar()
```





```python
from functools import wraps 
#定义一个装饰器名称的类
class  with_para_decorator: 
    #在类的__init__函数内接受装饰器参数，并赋值给类的实例参数，这样可以让其他函数随时使用
    #当然，如果装饰器没有参数，此处不转a,b即可，相当于类无参实例化
    def __init__(self,a,b):    
        self.a=a
        self.b=b
    #在类的__call__函数内接受被装饰函数，并具体定义装饰器
    def __call__(self,func):   
    	@wraps(func)   
        def wrap_function(arg1,arg2):  
            print('装饰带参数的函数，函数传的参数为：{0}, {1}'.format(arg1,arg2))
            print('带参数的装饰器，装饰器传的参数为：{0}, {1}'.format(self.a,self.b))
            return func(arg1,arg2)   
        return wrap_function

#使用装饰器
@with_para_decorator(1,2)  # 类的实例化对象 当做函数 接受实际被调用的函数
def need_decorate(a,b):   
pass
need_decorate(4,5) 
```













#### 多个装饰器调用顺序

```python
@a
@b
@c
def f ():
    pass

# 等价于
f = a(b(c(f)))

```







#### @wraps

##### 原因

```python
def logged(func):
    def with_logging(*args, **kwargs):
        print(func.__name__)      # 输出 'with_logging'
        print(func.__doc__)       # 输出 None
        return func(*args, **kwargs)
    return with_logging

# 函数
@logged
def f(x):
   """does some math"""
   return x + x * x
print(f(1))

#  由于装饰器的本质是：f=logged(f),f指向的是被封装的with_logging函数
print(f.__name__) # with_logging
print(f.__doc__)  # None
```





##### 本质

```python
def Wraps(fWrap): # 接受 被包裹的函数；被包裹函数在 包裹函数中被调用，需要包裹函数的某项功能
    def TmpWraps(func): # 接受 包裹函数
        def WrapsDecorator(*args, **kwargs): # 外界赋值时接受的 真正的函数
            return func(*args, **kwargs)
        
        #逐个获取fwrap函数的元信息，并复制到WrapsDecorator函数上
        meta_info=['__module__', '__name__', '__qualname__', '__doc__', '__annotations__']
        for meta in meta_info:
            setattr(WrapsDecorator,meta,getattr(fwrap,meta))
            
        return WrapsDecorator
    return TmpWraps
```









#### 案列

##### 控制函数调用

```python
from functools import wraps
def decorator_name(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if not can_run:
            return "Function will not run"
        return f(*args, **kwargs)
    return decorated
 
@decorator_name
def func():
    return("Function is running")
 
can_run = True
print(func())
# Output: Function is running
 
can_run = False
print(func())
```





##### 授权

```python
from functools import wraps
 
def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_auth(auth.username, auth.password):
            authenticate()
        return f(*args, **kwargs)
    return decorated
```





##### 日志

```python
from functools import wraps
 
def logit(func):
    @wraps(func)
    def with_logging(*args, **kwargs):
        print(func.__name__ + " was called")
        return func(*args, **kwargs)
    return with_logging
 
@logit
def addition_func(x):
   """Do some math."""
   return x + x
 
 
result = addition_func(4)
# Output: addition_func was called
```







**调用记录写入到某一文件**

```python
from functools import wraps
 
def logit(logfile='out.log'):
    def logging_decorator(func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + " was called"
            print(log_string)
            # 打开logfile，并写入内容
            with open(logfile, 'a') as opened_file:
                # 现在将日志打到指定的logfile
                opened_file.write(log_string + '\n')
            return func(*args, **kwargs)
        return wrapped_function
    return logging_decorator
 
@logit()
def myfunc1():
    pass
 
myfunc1()
# Output: myfunc1 was called
# 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串
 
@logit(logfile='func2.log')
def myfunc2():
    pass
 
myfunc2()
# Output: myfunc2 was called
# 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串
```









## 面向对象

### 注意事项 | !

```python
# 存在类属性
    class Foo:
        a="bar" # 类属性
        def __init__(self,a):
            self.a=a
        def hi(self):
			print(self)    
    f=Foo(1)
    f.hi() # <__main__.Foo object at 0x7ff802aaa670>
    # 类只需要主动传递一个参数就可以访问 实例方法
	Foo.hi(1)	# 1  
    print(f.a)		# 1
    print(Foo.a)	# bar
    
# 所谓的 实例方法 与 类方法（classmethod修饰） 以及 静态方法(staticmethod修饰),本质差距不大
	实例 可以访问以上所有方法
    	访问 实例方法（其实是被包装的方法）时，会自动传入self
        访问 类方法时（也是被包装的方法），会自动传入类cls
        访问 静态方法，不会传递任何值 # 主要用来被修饰
    类本身 也可以，主要是在访问实例方法是需要主动传入一个（参数)实例
    
    
# ===========================
# 自己实现 staticmethod 和 classmethod
from functools import wraps
def classmethod(func):
    @wraps(func)
    def TmpWrapper(self,*args,**kwargs):
        return func(self.__class__,*args,**kwargs) # 将系统传递self 换成 其cls(所属类)
    return TmpWrapper

def staticmethod(func):
    @wraps(func)
    def TmpWrapper(self,*args,**kwargs):
        return func(*args,**kwargs) # 舍弃系统传递的self
    return TmpWrapper
```





```python
# 类的实例化操作会自动调用 __init__() 方法
# 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self
	self代表类的实例，而非类
    self 不是 python 关键字，我们把他换成 其他值 也是可以正常执行的:
        
# 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。
	基类名 必须与派生类定义在一个作用域内
    
    
# 同样有限的支持多继承形式
注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法

class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
    
  
# 私有成员
	两个下划线开头，声明该成员（方法或属性）为私有成员，只能在类的内部调用 ，不能在类的外部调用
```





### 单继承

```python
#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
        
    def speak(self):
        print("%s 说: 我 %d 岁。" %(self.name,self.age))
    def hi(self):
        print(self)
        print(self.__class__)
 
# 实例化类
p = people('runoob',10,30)
p.speak()


# ==============继承=============
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade))
 
 
 
s = student('ken',10,60,3)
s.speak()
```







### 多继承

注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，**从左到右**查找父类中是否包含方法



```python
#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print("%s 说: 我 %d 岁。" %(self.name,self.age))
 
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade))
 
#另一个类，多重继承之前的准备
class speaker():
    topic = ''
    name = ''
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print("我叫 %s，我是一个演说家，我演讲的主题是 %s"%(self.name,self.topic))
 
#多重继承
class sample(speaker,student):
    a =''
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)
 
test = sample("Tim",25,80,4,"Python")
test.speak()   #方法名同，默认调用的是在括号中参数位置排前父类的方法
```





### super关键字

#### 绑定父类方法

1、调用未绑定的超类构造方法（多用于旧版 python 阵营）

```python
class SongBird(Bird):
     def __init__(self):
            # 手动绑定每个父类，如果多继承时将会很麻烦
          Bird.__init__(self)
          self.sound = 'Squawk'
     def sing(self):
          print self.song()
```

**原理**：在调用了一个实例的方法时，该方法的self参数会自动绑定到实例上（称为绑定方法）；如果直接调用类的方法（比如Bird.__init__），那么就没有实例会被绑定，可以自由提供需要的self参数（未绑定方法）。



2、使用super函数（只在新式类中有用）

```python
class SongBird(Bird):
     def __init__(self):
          # 自动绑定所有的父类，它会查找所有的超类，以及超类的超类，直到找到所需的特性为止。
          super(SongBird,self).__init__()
            
          # 其实在python3中还可以简化成
          # super().__init__()
            
          self.sound = 'Squawk'
     def sing(self):
          print self.song()
```





#### 菱形继承

```python
# Python3 中继承遵循广度优先原则：

class A():
    def __init__(self):
        print('enter A')
        print('leave A')


class B(A):
    def __init__(self):
        print('enter B')
        super().__init__()
        print('leave B')


class C(A):
    def __init__(self):
        print('enter C')
        super().__init__()
        print('leave C')


class D(B, C):
    def __init__(self):
        print('enter D')
        super().__init__()
        print('leave D')
       
d=D()

# 执行结果
# enter D
# enter B
# enter C
# enter A
# leave A
# leave C
# leave B
# leave D
```





#### 子类省略init

```python
class Father(object):
    def __init__(self, name):
        self.name=name
        print ( "name: %s" %( self.name) )
    def getName(self):
        return 'Father ' + self.name
 
class Son(Father):
    # 子类不重写 **__init__**，实例化子类时，会自动调用父类定义的 **__init__**。
    def getName(self):
        return 'Son '+self.name
 
if __name__=='__main__':
    son=Son('runoob')
    print ( son.getName() )
```





### 方法重写

```python
class Parent:        # 定义父类
   def myMethod(self):
      print ('调用父类方法')
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print ('调用子类方法')
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法
```









### 运算符重载 | !!

#### 注意点

```python
# == 比较的是内容，而不是id
a={"a":[]}
b={"a":[]}
c=[]
d=[]
print(id(a),id(b)) # 140357228184128 140357228184192
print(a == b) # True
print(a["a"] == b["a"]) # True
print(c == d ) # True
```





#### 总览

```python
__name__
__doc__
__class__ 构造函数
__bases__ 父类簇
__dict__  类体（所有成员）
　　# 1） 内置的数据类型没有__dict__属性
　　# 2） 每个类有自己的__dict__属性，就算存着继承关系，父类的__dict__ 并不会影响子类的__dict__
　　# 3） 对象也有自己的__dict__属性， 存储self.xxx 信息，父子类对象公用__dict__	

__init__ : 构造函数，在生成对象时调用
__new__
		# 继承原生int,str,tuple时
__instancecheck__
	# 针对方法isinstance
__subclasscheck__
	# 针对方法issubclass
__subclasshook__
__del__ : 析构函数，释放对象时使用
    
    
    
__repr__ : 打印，转换
    	# 在当调用 repr(instance) 时被调用。repr 函数是一个内置函数，它返回一个对象的字符串表示
        # 在交互式窗口中，当你只敲入一个变量名，接着按 ENTER，Python 使用 repr 来显示变量的值
__str__
		# 使用print(instance)时
__len__: 
    	# 获得长度
__sizeof__
		# 返回对象的内存大小。 比len()多了一个垃圾收集器开销
__format__
 	# ，当应用程序中出现"{0:specification}".format(someobject)或format(someobject, specification)时，会默认以这种方式调用
　　# 当specification为" "时，一种合理的返回值是return str(self),这为各种对象的字符串表示形式提供了明确的一致性
    
    
__iter__
__next__
    # for...in迭代
    

__getslice__、__setslice__、__delslice__
	# 分别用于分片操作，如列表的切片
    # 魔法属性(只限python2.x版本，python3.x无此功能)：
__setitem__ : 按照索引赋值
__getitem__: 按照索引获取值
    	# 要像list一样按照索引来获取元素，需要实现__getitem__()方法
        # []运算符？
__delitem__
		# del instance[key]

__getattr__
    # 正常情况下，调用类的方法或属性时，如果类的方法或属性不存在就会报错
    # .运算符？
    
    
    
__call__: 函数调用
    # 对实例进行直接调用就像对一个函数调用一样，完全可以把对象看成函数
    
    
__cmp__: 比较运算
    	#  sorted() 按照默认的比较函数 cmp 排序
__hash__
	# 加入集合时 比较对象是否相等关键
__eq__
    	# 使用 ==
__contains__
		# in操作符；a in obj
__lt__、__gt__、__le__、__ge__、__eq__和__ne__   
		# 富比较方法
    	# 在自定义类中实现了__eq__和__ne__这两个方法，则“==”和“!=”的两个对象比较分别调用了这两个方法进行比较
        # 在自定义类中只实现了__eq__方法，未实现__ne__方法，则“==”和“!=”都是__eq__方法，调用的两个对象比较都调用__eq__方法进行比较，不过后者是对__eq__取反
    	# 在自定义类中实现了__ne__方法，未实现__eq__方法，则“!=”调用__ne__方法，而eq则调用系统内置的“==”对应的方法，老猿初步分析应该是调用“is”，还没求证
    
    
    
    
#运算操作
# 比如：A+B，激发A的__add__,激发B的__radd__
'''
当解释器碰到 a+b 时，会做以下事情：
从 a 类中找 __add__ 若返回值不是 NotImplemented, 则调用 a.__add__(b)。
若 a 类中没有 __add__ 方法，则检查 b 有没有 __radd__ 。如果如果有，则调用 b.__radd__(a)，若没有，则返回 NotImplemented。
接上条，若 b 也没有 __radd__ 方法，则抛出 TypeError，在错误消息中知名操作数类型不支持
'''
# 但则存在一个问题，最后谁的结果是最终值？
__add__: 加运算
__sub__: 减运算
__mul__: 乘运算
__truediv__: 除运算
__mod__: 求余运算
__pow__: 乘方
   
# 反向运算
__radd__: 加运算
__rsub__: 减运算
__rmul__: 乘运算
__rdiv__: 除运算
__rmod__: 求余运算
__rpow__: 乘方

# 复合运算
# 针对 += 运算，比如列表list,L1+=L2，是将L2添加到L1后面
__iadd__: 加运算
__isub__: 减运算
__imul__: 乘运算
__idiv__: 除运算
__imod__: 求余运算
__ipow__: 乘方
```



#### 案列一 getslice

```python
class Foo(object):
    save_list = [1, 2, 3, 4, 5, 6, 34, 23, 5]

    def __getslice__(self, i, j):
        print "__getslice__:"
        return self.save_list[i: j]

    def __setslice__(self, i, j, sequence):
        print "__setslice__:"
        self.save_list[i:j] = sequence
        print self.save_list

    def __delslice__(self, i, j):
        print "__delslice__:"
        del self.save_list[i: j]
        print self.save_list


obj = Foo()
result = obj[1: 2]
print(result)
obj[0: 1] = [23, 22, 15, 4]
del obj[4:]

"""
结果：
__getslice__:
[2]
__setslice__:
[23, 22, 15, 4, 2, 3, 4, 5, 6, 34, 23, 5]
__delslice__:
[23, 22, 15, 4]
"""
```







#### 案列二 iter

```python
class Fib:
    def __init__(self,end):
        self.__a=0
        self.__b=1
        self.end=end
    def __iter__(self):
        # 返回对象必须具有__next__方法
        return self
    def __next__(self):
        return this.__a,this.__b=this.__b,this.__a + this.__b
    
    def __getitem__(self,index):
        a=0
        b=1
        for(i in range(index)):
        	a,b=b,a+b
        return a
```





#### 案列三 add

```python
class Vector:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __str__(self):
        return 'Vector (%d, %d)' % (self.a, self.b)

    def __repr__(self):
        return 'Vector (%d, %d)' % (self.a, self.b)

    def __add__(self,other):
        if other.__class__ is Vector:
            return Vector(self.a + other.a, self.b + other.b)
        elif other.__class__ is int:
            return Vector(self.a+other,self.b)

    def __radd__(self,other):
        """反向算术运算符的重载
        __add__运算符重载可以保证V+int的情况下不会报错，但是反过来int+V就会报错，通过反向运算符重载可以解决此问题
        """

        if other.__class__ is int or other.__class__ is float:
            return Vector(self.a+other,self.b)
        else:
            raise ValueError("值错误")

    def __iadd__(self,other):
        """复合赋值算数运算符的重载
        主要用于列表，例如L1+=L2,默认情况下调用__add__，会生成一个新的列表，
        当数据过大的时候会影响效率，而此函数可以重载+=，使L2直接增加到L1后面
        """

        if other.__class__ is Vector:
            return Vector(self.a + other.a, self.b + other.b)
        elif other.__class__ is int:
            return Vector(self.a+other,self.b)
v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)
print (v1+5)
print (6+v2)
```





```python
class Vector:
	def __init__(self, a, b):
		self.a = a
		self.b = b
	def __repr__(self):
        # 等价于 __str__
		print("called")
		return 'Vector (%d, %d)' % (self.a, self.b)
	def __add__(self,other):
		return Vector(self.a + other.a, self.b + other.b)
v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)
```



#### 案列三 cmp

```python
class Student(object):  
  
    def __init__(self, name, score):  
        self.name = name  
        self.score = score  
  
    def __str__(self):  
        return '(%s: %s)' % (self.name, self.score)  
  
    __repr__ = __str__  
  
    def __cmp__(self, s):  
        if self.score>s.score:  
            return -1  
        elif self.score<s.score:  
            return  1  
        else :  
             if self.name<s.name:  
                 return -1  
             elif self.name>s.name:  
                 return 1  
             else:  
                 return 0  
          
  
L = [Student('Tim', 99), Student('Bob', 88), Student('Alice', 99)]  
print sorted(L)  
```







#### 案列四 eq | hash

```python
class A:
    def __eq__(self, other):
        print(self)
        print(other)
        # if self.__dict__ == other.__dict__:
        if self == other:   # 此处相当于一直在反复的执行 a == b
            return True
a = A()
b = A()
# print(a)
# print(b)
print(a == b)

# 报错
# RecursionError: maximum recursion depth exceeded while getting the str of an object
```







```python
class Foo:
    def __init__(self, item):
        self.item = item

    def __eq__(self, other):
        print('使用了equal函数的对象的id',id(self))
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        else:
            return False
    def __hash__(self):
        print('f'+str(self.item)+'使用了hash函数')
        return hash(self.item)       
f1 = Foo(1)
f2 = Foo(2)
f3 = Foo(3)
fset = set([f1, f2, f3])
print(fset)
print()
f = Foo(3)
fset.add(f)
print('f3的id:',id(f3))
print('f的id:',id(f))

# 结果
'''
f1使用了hash函数
f2使用了hash函数
f3使用了hash函数
{<__main__.Foo object at 0x0000023769AB67C0>, <__main__.Foo object at 0x0000023769AC5C10>, <__main__.Foo object at 0x0000023769AC5C40>}

f3使用了hash函数
使用了equal函数的对象的id 2437019360320
f3的id: 2437019360320
f的id: 2437019360368
'''

'''
可见，在将f1,f2,f3加入到set中时，每次都会调用一次__hash__函数。
由于我定义的___hash__函数是return hash(self.item)，所以f和f3找到的桶的位置是同一个位置，因为它俩的item是相同的。当执行fset.add(f)时，f就会调用它自身的__hash__函数，以找到f所属于的桶的位置。但此时桶里已经有别的球了，所以这时候就得用上__eq__来判断两个对象是否相等，从输出可以看出，是已有对象调用__eq__来和后来的对象进行比较（看对象的id）。
'''


'''
当可哈希集合（set,frozenset,dict）调用hash函数时，应该返回一个int值。唯一的要求就是，如果判断两个对象相等，那么他们的hash值也应该相等。当比较两个对象相等时是使用对象的成员来比较时，建议要把成员弄进元祖里，再得到这个元祖的hash值来比较。

当class没有定义__eq__()方法时，那么它也不应该定义__hash__()方法。如果它定义了__eq__()方法，却没有定义__hash__()方法，那么这个类的实例就不能在可哈希集合使用。如果一个类定义了一个可变对象（这里应该是指class的成员之一为可变对象），且implement了__eq__()方法，那么这个类就不应该implement hash()方法，因为可哈希对象的实现（implement ）要求键值key的hash值是不变的（如果一个对象的hash值改变了，那么它会被放在错误的hash桶里）

用户定义的类中都有默认的__eq__和__hash__方法；有了它，所有的对象实例都是不等的（除非是自己和自己比较），在做x == y比较时是和这个等价的hash(x) == hash(y)。
'''

```

















#### 案列五 format

```python
class formatest:
    def __init__(self, name, age):
        self.name,self.age = name, age

    def __format__(self,specification):
        if specification == "":
            return str(self)

        strformat = specification.replace("%s",self.name).replace("%r",self.age)
        return strformat

if __name__ == "__main__":
    people = formatest("zhanglin", "31")
    print ("{}".format(people))
    print ("{0:%s-%r}".format(people)) # 打印结果：zhanglin-31
    print (format(people, "%s-%r")) # 打印结果：zhanglin-31
```



#### 案列六 instancecheck

https://www.cnblogs.com/traditional/p/11731676.html







### 元类 | !!!

https://www.cnblogs.com/sui776265233/p/9244659.html

```python
'''
1、什么是元类
    在python中一切皆对象，那么我们用class关键字定义的类本身也是一个对象
    负责产生该对象的类称之为元类，即元类可以简称为类的类

    class Foo: # Foo=元类()        #一切皆对象，类加括号产生对象
        pass
2、为何要用元类
    元类是负责产生类的，所以我们学习元类或者自定义元类的目的
    是为了控制类的产生过程，还可以控制对象的产生过程

3、如何用元类

'''
#1、储备知识：内置函数exec的用法
cmd="""
x=1
def func(self):
    pass
"""
class_dic={}
exec(cmd,{},class_dic)     #exec会将cmd字符串中的代码拿出来执行一次，将产生的名字丢掉事先定义好的class_dic空字典中

print(class_dic)            #{'x': 1, 'func': <function func at 0x00000267165F92F0>}


#2、创建类的方法有两种
# 大前提：如果说类也是对象的话，那么用class关键字去创建类的过程也是一个实例化的过程
# 该实例化的目的是为了得到一个类，调用的是元类
#2.1 方式一：用的默认的元类type
class People: #People=type(...)--------默认的元类type实例化出一个对象Pelple,实例化的结果也是一个对象
    country='China'
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def eat(self):
        print('%s is eating' %self.name)
peo=People('EGON',18)
print(peo)               #------------<__main__.People object at 0x000001F635282E10>*********调用类实例化出对象
print(type(People))      #------------<class 'type'>*****************************************调用元类实例化出类



"""重点"""
#2.1.1 创建类的3个要素：类名，基类，类的名称空间
class_name='People'         #类名，是一个字符串，---------由上面的class定义类我们知道，创建类的三要素：类名，基类，类的名称空间
class_bases=(object,)       #基类，----------------------我们通过__bases__,知道基类是一个元组的形式
class_dic={}                #类的名称空间，---------------通过__dict__,知道类的名称空间的是一个字典
class_body="""              
country='China'
def __init__(self,name,age):
    self.name=name
    self.age=age

def eat(self):
    print('%s is eating' %self.name)
"""                          #--------将类体代码放到一个字符串中
exec(class_body,{},class_dic)#执行字符传中的代码，将产生的名字方到class_dic的名称空间中，即之前定义类将产生的名字放到类的名称空间中

# 准备好创建类的三要素
# print(class_name)        #-------People
# print(class_bases)       #-------(<class 'object'>,)
# print(class_dic)         #-------{'country': 'China', '__init__': <function __init__ at 0x00000222D55F92F0>, 'eat': <function eat at 0x00000222DC618BF8>}

# People=type(类名，基类，类的名称空间)                #调用元类就可以产生一个类这个对象
People1=type(class_name,class_bases,class_dic)      #将事先定义好的类的三要素放到当做参数传给元类，调用元类即产生对象
print(People1)             #--------<class '__main__.People'>自定义类产生的结果
obj1=People1('egon',18)
print(People)              #--------<class '__main__.People'>，class定义类产生的结果
obj=People('egon',18)

obj1.eat()
obj.eat()


"""----------------------------------------重点----------------------------------------"""
#2.2 方式二：用的自定义的元类
class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类
    def __init__(self,class_name,class_bases,class_dic):
        print(self) #现在是People
        print(class_name)
        print(class_bases)
        print(class_dic)
        super(Mymeta,self).__init__(class_name,class_bases,class_dic) #重用父类的功能

# 分析用class自定义类的运行原理（而非元类的的运行原理）：
#1、拿到一个字符串格式的类名class_name='People'
#2、拿到一个类的基类们class_bases=(obejct,)
#3、执行类体代码，拿到一个类的名称空间class_dic={...}------------------前三步就是造类的三要素
#4、调用People=type(class_name,class_bases,class_dic)----------------调用元类（类）产生类（对象）------------调用类产生对象
class People(object,metaclass=Mymeta): #People=Mymeta(类名,基类们,类的名称空间)------metaclass=Mymeta是自定义的元类名
    country='China'
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def eat(self):
        print('%s is eating' %self.name)
"""----------------------------------------重点----------------------------------------"""





"""应用：自定义元类控制类的产生过程，类的产生过程其实就是元类的调用过程------（对象的产生过程就是调用类的过程）"""
class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类---------------必须要继承type类
    def __init__(self,class_name,class_bases,class_dic):                                      #在自定义类之上添加逻辑判断
        if class_dic.get('__doc__') is None or len(class_dic.get('__doc__').strip()) == 0:    #必须有文档注释，且不为空
            raise TypeError('类中必须有文档注释，并且文档注释不能为空')
        if not class_name.istitle():                                                          #类的首字母必须大写
            raise TypeError('类名首字母必须大写')
        super(Mymeta,self).__init__(class_name,class_bases,class_dic)                         #重用父类的功能

class People(object,metaclass=Mymeta): #People=Mymeta('People',(object,),{....})
    """这是People类"""
    country='China'
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def eat(self):
        print('%s is eating' %self.name)



#3 储备知识：__call__
class Foo:
    def __call__(self, *args, **kwargs):
        print(self)      #<__main__.Foo object at 0x000002193E892E10>
        print(args)       #(1, 2, 3)----------------*args接收位置参数，存成元组的形式
        print(kwargs)     #{'x': 1, 'y': 2}---------**kwargs接收关键字参数，存成字典的形式


obj=Foo()          #调用类不会自动触发，会在调用对象时自动触发，通过self也可以看出，是调用对象时自动触发

# # 要想让obj这个对象变成一个可调用的对象，需要在该对象的类中定义一个方法__call__方法
# # 该方法会在调用对象时自动触发
# obj(1,2,3,x=1,y=2) #调用对象时自动触发__call__方法，并将对象自动传入



"""-----------------------------------------------重点---------------------------------------------"""
# 4、自定义元类来控制类的调用的过程，即类的实例化过程
class Mymeta(type):

    def __call__(self, *args, **kwargs):          #会在调用对象时自动触发，此时的对象时一个类，即People
        # print(self) # self是People
        # print(args)
        # print(kwargs)
        # return 123
        """调用类产生一个对象，发生两件事"""       #和class定义类，调用类一样发生两件事
        # 1、先造出一个People的空对象
        obj=self.__new__(self)                   #造出了一个自定义类People的空对象
        # 2、为该对空对象初始化独有的属性
        # print(args,kwargs)
        self.__init__(obj,*args,**kwargs)        #对空对象进行初始化，空对象传入，以及参数原封不动的传入

        # 3、返回一个初始好的对象
        return obj                               #将造出的对象返回，

'''**********************************看成一个对象************************************************'''
class People(object,metaclass=Mymeta):           #自定义类People，元类是Mymeta,元类必须继承type类，否则就不是元类
    country='China'
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def eat(self):
        print('%s is eating' %self.name)

    def __new__(cls, *args, **kwargs):           #对象自己中有__new__属性,先从对象自己的名称空间中找，自己没有在到自己的类中找
        print(cls)
        # cls.__new__(cls) # 错误                 #自己有调用了自己的__new__,这样就出现无线递归，所以会报错
        obj=super(People,cls).__new__(cls)       #自己中有，我们任然让其取继承父类中的__new__属性,来产生一个空对象，然后将对象初始化，拿到一个返回值
        return obj
'''**********************************看成一个对象************************************************'''

"""-----------------------------------------------重点---------------------------------------------"""



# 分析：调用Pepole的目的
#1、先造出一个People的空对象
#2、为该对空对象初始化独有的属性
# obj1=People('egon1',age=18)
# obj2=People('egon2',age=18)
# print(obj1)
# print(obj2)

# obj=People('egon',age=18)
# print(obj.__dict__)
# print(obj.name)
# obj.eat()
```















### 类的静态方法、普通方法、类方法

```python
class Test(object):
    def InstanceFun(self):
        print("InstanceFun");
        print(self);
    @classmethod
    def ClassFun(cls):
        print("ClassFun");
        print(cls);
    @staticmethod
    def StaticFun():
        print("StaticFun");

t = Test();　　　　　
t.InstanceFun();　　　# 输出InstanceFun，打印对象内存地址“<__main__.Test object at 0x0293DCF0>”
Test.ClassFun();     # 输出ClassFun，打印类位置 <class '__main__.Test'>
Test.StaticFun();    # 输出StaticFun
t.StaticFun();       # 输出StaticFun
t.ClassFun();        # 输出ClassFun，打印类位置 <class '__main__.Test'>
Test.InstanceFun();     # 错误，TypeError: unbound method instanceFun() must be called with Test instance as first argument
Test.InstanceFun(t);    # 输出InstanceFun，打印对象内存地址“<__main__.Test object at 0x0293DCF0>”
t.ClassFun(Test);       # 错误   classFun() takes exactly 1 argument (2 given)   
```

可以看到，在 Python 中，两种方法的主要区别在于参数。**实例方法隐含的参数为类实例 self，而类方法隐含的参数为类本身 cls**。

静态方法无隐含参数，主要为了类实例也可以直接调用静态方法。

所以逻辑上类方法应当只被类调用，实例方法实例调用，静态方法两者都能调用。主要区别在于参数传递上的区别，实例方法悄悄传递的是self引用作为参数，而类方法悄悄传递的是 cls 引用作为参数。

Python 实现了一定的灵活性使得类方法和静态方法，都能够被实例和类二者调用。





```python

					实例								类
实例方法										需要额外传入实例
类方法
静态方法
```









### 私有属性是可以修改

```python
class People:
    def __init__(self, name, age, ):
        self.name = name
        self.age = age
        self.__privater_var = 10  
  
    def intro(self):
        print(f'My name is {self.name},I\'m {self.age}')

    def get_var(self):
        print(self.__privater_var)

    def set_var(self, var):
        self.__privater_var = var

        
someone = People(name='jack', age=20)
print(dir(someone))

# ['_People__privater_var', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'get_var', 'intro', 'name', 'set_var']

# 我们并没有找到'_peivater_var'但是我们看到一个'_People__privater_var'.有没有想到什么？原来是被重命名了。好，我们来试试：

print(someone._People__privater_var)
someone._People__privater_var = 40
print(someone._People__privater_var)
```







## 迭代器与生成器

```python
import sys         # 引入 sys 模块
 
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
 
while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
```





### 创建迭代器

```python
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)
 
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))

# StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a <= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
 
for x in myiter:
  print(x)
```





```python
class Fibonacci:
	def __init__(self, count):
		self.count = count

	def __iter__(self):
		self.i = 0
		self.a, self.b = 0, 1
		return self

	def __next__(self):
		if self.i < self.count:
			self.i = self.i + 1
			a_old = self.a
			self.a, self.b = self.b, self.a + self.b
			return a_old
		else:
			raise StopIteration
			
for i in Fibonacci(10):
  print(i, end=" ")
```















### 生成器

每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行



一个函数 f，f 返回一个 list，这个 list 是**动态计算**出来的（不管是数学上的计算还是逻辑上的读取格式化），并且这个 list 会很大（无论是固定很大还是随着输入参数的增大而增大），这个时候，我们希望每次调用这个函数并使用迭代器进行循环的时候一个一个的得到每个 list 元素而不是直接得到一个完整的 list 来**节省内存**，这个时候 yield 就很有用



当函数执行结束时，generator 自动抛出 StopIteration 异常，表示迭代完成。在 for 循环里，无需处理 StopIteration 异常，循环会正常结束。

如果没有 return，则默认执行至函数完毕，**如果在执行过程中 return，则直接抛出 StopIteration 终止迭代**。

```python
import sys
 
def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter > n): 
            return
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成
 
while True:
    try:
        print (next(f), end=" ")
    except StopIteration:
        sys.exit()
```







#### 协程

变相实现协程的效果，即在同一个线程内，实现不同任务交替执行

```python
def mytask1():
  print('task1 开始执行')
  '''
  task code
  '''
  yield

def mytask2():
  print('task2 开始执行')
  '''
  task code
  '''
  yield

gene1=mytask1()
gene2=mytask2()

for i in range(100):
  next(gene1)
  next(gene2)
```





#### 文件读取

```python
def read_file(fpath): 
    BLOCK_SIZE = 1024 
    with open(fpath, 'rb') as f: 
        while True: 
            block = f.read(BLOCK_SIZE) 
            if block: 
                yield block 
            else: 
                return
```











## 模块

### 注意事项

https://www.cnblogs.com/xingxia/p/python_package_module.html

https://www.cnblogs.com/jiaxin359/p/7580375.html

https://blog.csdn.net/weixin_42223833/article/details/86168012

```python
# sys.path 就是搜索路径；搜索路径是一个解释器会先进行搜索的所有目录的列表
	搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块
# 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。
	模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行
    
# from fibo import *
	这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。
    注意，由于引用其他模块的所有变量，很可能覆盖了已有的定义。
    
# 用__name__属性来使该程序块仅在该模块自身运行时执行。

# 包
	包=>文件夹，模块=>文件
'''
目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包

注意当使用 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。
import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 :exc:ImportError 异常。
反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。


如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入
__all__ = ["echo", "surround", "reverse"]


自从python2.6，一个模块的名称是由__package__+'.'+__name__来确定的，如果__packege__是None的话，那么这个名称就是__name__了。
from . import echo
from .. import formats
from ..filters import equalizer
	比如，现在模块的名称是package.subpackage1.moudleX,然后..moduleA中的两个点号表示的是上升两个层级，到达package，然后package和moduleA结合，最终成为package.moduleA。要让from .. import这样的相对导入正常工作，模块的名称中至少要有和语句中相对应的“点”的数量
	如果你的模块的名称是__main__，那么它就不被认为是在一个包当中，因为它的名称当中不含有“点”，所以你不能在它的里面使用from .. import。如果你使用了这个语句，那么程序就会报“relative-import in non-package"错误。
	如果你想直接运行moduleX，但是你又想把它当做一个包的一部分，你可以使用python -m package.subpackage.moduleX. -m参数告诉python把它当做一个模块来加载，而不是顶层的脚本

import path1.path2.path3.modname1
那么你可以用as关键字给它重命名，以便于缩短代码宽度，维持可读性


import sys
sys.path.append("D:\\test")

'''


# python import 引用上上上级包的三种方法
'''
# 方法二
相对引用

# 方法二
import sys
import os
CURRENT_DIR = os.path.split(os.path.abspath(__file__))[0]  # 当前目录
config_path = CURRENT_DIR.rsplit('/', 3)[0]  # 上三级目录
sys.path.append(config_path)
from config import param
print('config_path=', config_path)
print(sys.path)
print(param)


# 方法三
import path, sys
folder = path.path(__file__).abspath()
sys.path.append(folder.parent.parent)
'''
```

![image-20211202051110386](F:\code\Python\imgs\image-20211202051110386.png)









### 案列

如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。

为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。

模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py

```python
import sys
 
print('命令行参数如下:')
for i in sys.argv:
   print(i)
 
print('\n\nPython 路径为：', sys.path, '\n')

'''
命令行参数如下:	# sys.argv 第一个参数是文件名
moduleA.py 
a
b


# sys.path 是 一串列表，第一项为当前文件所在的目录

Python 路径为： ['F:\\code\\Python', 'F:\\environmen\\Python 3.9\\python39.zip', 'F:\\environmen\\Python 3.9\\DLLs', 'F:\\environmen\\Python 3.9\\lib', 'F:\\environmen\\Python 3.9', 'C:\\Users\\汪宇\\AppData\\Roaming\\Python\\Python39\\site-packages', 'F:\\environmen\\Python 3.9\\lib\\site-packages']
'''


# ==============================

#!/usr/bin/python3
# Filename: support.py
def print_func( par ):
    print ("Hello : ", par)
    return



#!/usr/bin/python3
# Filename: test.py
# 导入模块
import support
# 现在可以调用模块里包含的函数了
support.print_func("Runoob")

```





## 错误与异常

```python
# 让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常

while True:
    try:
        x = int(input("请输入一个数字: "))
        break
    except ValueError:
        print("您输入的不是数字，请再次尝试输入！")
        
        '''
try 语句按照如下方式工作；
	1.首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。
	2.如果没有异常发生，忽略 except 子句，try 子句执行后结束。
	3.如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。
	4.如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。
        '''
        
        
# 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行
# 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:
	as 重新命名错误
# 最后一个except子句可以忽略异常的名称，它将被当作通配符使用
    except (RuntimeError, TypeError, NameError):
        pass
    
# else 子句将在 try 子句没有发生任何异常的时候执行
# try-finally 语句无论是否发生异常都将执行最后的代码

# 使用 raise 语句抛出一个指定的异常
x = 10
if x > 5:
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
    
>>> try:
        raise NameError('HiThere')
    except NameError:
        print('An exception flew by!') 
        raise # 直接抛出捕获的异常
        
        
 '''
 assert
 	用于判断一个表达式，在表达式条件为 false 的时候触发异常
 语法1：
 	assert expression
 	
 	等价于：
 	if not expression:
    	raise AssertionError
    	
 语法2：
 	assert expression [, arguments]
 	
 	等价于：
 	if not expression:
    	raise AssertionError(arguments)
    	
 案列1：
 	assert 1==2, '1 不等于 2'
  案列2：
  	import sys
	assert ('linux' in sys.platform), "该代码只能在 Linux 下执行"
 '''
        
        
# 用户自定义异常
>>> class MyError(Exception): # 异常类继承自 Exception 类，可以直接继承，或者间接继承
        def __init__(self, value):
            self.value = value
        def __str__(self):
            return repr(self.value)
   
>>> try:
        raise MyError(2*2)
    except MyError as e:
        print('My exception occurred, value:', e.value)
        
        
# 预定义的清理行为
with open("myfile.txt") as f:
    for line in f:
        print(line, end="")
```







![image-20211202202952298](F:\code\Python\imgs\image-20211202202952298.png)



### 内置异常类型的结构

```python
# 将会捕获除了 SystemExit 、 KeyboardInterrupt 和 GeneratorExit 之外的所有异常。 如果你还想捕获这三个异常，将 Exception 改成 BaseException 即可
try:
   ...
except Exception as e:
```





```python
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
```











## 文件读写

```python
# 关于 str() 和 repr() 的区别
str() 更注重可读性，repr() 更注重数据本身的信息
 str() 的输出追求可读性，输出格式要便于理解，适合用于输出内容到用户终端。
 repr() 的输出追求明确性，除了对象内容，还需要展示出对象的数据类型信息，适合开发和调试阶段使用。

open(filename, mode)
	# 返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError
	# 默认文件访问模式为只读(r)
    # r w a 
    	# b +
        
	read(size)
    	# 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回
    readline()
    	# 从文件中读取单独的一行。换行符为 '\n'。
        # f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。
    write(string) 
    	# 将 string 写入到文件中, 然后返回写入的字符数
        # 如果要写入一些不是字符串的东西, 那么将需要先通过str转换为字符串
    writelines
    	# 序列字符串,如一个字符串列表
        # writelines(["菜鸟教程 1\n", "菜鸟教程 2"])
    tell()
        # 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数
    seek(offset, from_what) 
    	# 改变文件当前的位置,from_what 值为默认为0，即文件开头
        '''
        seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符
        seek(x,1) ： 表示从当前位置往后移动x个字符
        seek(-x,2)：表示从文件的结尾往前移动x个字符
        '''
    close()
    	# 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常
        
    flush()
    	# 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。
        # 一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法
    truncate([size])
    	# Widnows 系统下的换行代表2个字节大小
        # 截断之后 文件 后面的所有字节被删除，即截取后的内容被清空
        # 如果不带size，默认截取当前位置后的所有字节
    fileno
    	# 得到int类型的文件描述
```





### 注意事项

```python
将 mode 设置为 w+ 或 a+ 时，发现直接进行读操作，得到的内容都是空，但原因不太相同：

如果 mode 设置为 w+，即使'没有执行 write 操作，也会将文件内容清空'，因此这个时候直接进行读草稿，读到的是空内容。

f = open("E:\\administrator\\Desktop\\test.txt", "w+")
如果 mode 设置为 a+，'文件指针位置默认在最后面'，因为读内容时，是按照指针的位置往后读，所以如果指针位置在最后，那读出来的是空，在读之前，一定要注意确认好指针位置是对的。

f = open("E:\\administrator\\Desktop\\test.txt", "a+")
f.write("append content")
print(f.tell())  #此时指针在文件字符末尾处
f.seek(0)
print(f.tell())  # 指针回到0的位置
str = f.read()
print(str)
f.close()f = open("E:\\administrator\\Desktop\\test.txt", "w+")
```







### 案列

```python
# 打开一个文件
f = open("/tmp/foo.txt", "w")

f.write( "Python 是一个非常好的语言。\n是的，的确非常好!!\n" )

# 关闭打开的文件
f.close()


#===================================


另一种方式是迭代一个文件对象然后读取每行:

#!/usr/bin/python3

# 打开一个文件
f = open("/tmp/foo.txt", "r")

for line in f:
    print(line, end='')

# 关闭打开的文件
f.close()

#=======================================

#!/usr/bin/python3

# 打开文件
fo = open("runoob.txt", "r+")
print ("文件名为: ", fo.name)

# 截取10个字节
fo.truncate(10) # r+光标指向文件头第一个字节，truncate(10)也就是截取此后的10个字节
				# 截取之后，后面的字节会被清除，也就是再打开文件时，只有这10个字节的内容
str = fo.read() # 读取截取的10个字节
print ("读取数据: %s" % (str))

# 关闭文件
fo.close()


#=======================================

# pickle模块实现了基本的数据序列和反序列化

#!/usr/bin/python3
import pickle
# 使用pickle模块将数据对象保存到文件
data1 = {'a': [1, 2.0, 3, 4+6j],
         'b': ('string', u'Unicode string'),
         'c': None}

selfref_list = [1, 2, 3]
selfref_list.append(selfref_list)
output = open('data.pkl', 'wb')

# Pickle dictionary using protocol 0.
pickle.dump(data1, output)

# Pickle the list using the highest protocol available.
pickle.dump(selfref_list, output, -1)

output.close()




#!/usr/bin/python3
import pprint, pickle

#使用pickle模块从文件中重构python对象
pkl_file = open('data.pkl', 'rb')

data1 = pickle.load(pkl_file)
pprint.pprint(data1)

data2 = pickle.load(pkl_file)
pprint.pprint(data2)

pkl_file.close()
```







|    模式    |  r   |  r+  |  w   |  w+  |  a   |  a+  |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |
|     读     |  +   |  +   |      |  +   |      |  +   |
|     写     |      |  +   |  +   |  +   |  +   |  +   |
|    创建    |      |      |  +   |  +   |  +   |  +   |
|    覆盖    |      |      |  +   |  +   |      |      |
| 指针在开始 |  +   |  +   |  +   |  +   |      |      |
| 指针在结尾 |      |      |      |      |  +   |  +   |











## sys模块

```python
# https://www.liujiangblog.com/course/python/54

import sys

	stdout
    stdin
    stderr
    	'''
    	与文件一样，具有read().write().flush()等方法
    	
    	'''
        
        
    platform
    version
    
    argv
    	# 第一个元素是脚本名称，从第二个元素开始才是真正的参数
    path
    	# 第一个元素通常是个空字符串，表示当前目录
        # 目录列表，供Python从中查找模块
    exit
    
sys.modules	
	# 以字典的形式返回所有当前Python环境中已经导入的模块
sys.builtin_module_names	
	# 返回一个列表，包含所有已经编译到Python解释器里的模块的名字

sys.getrefcount(object)
	# 返回对象的引用数量
    # 注意，这个次数默认从1开始，此外在使用sys.getrefcount(object)方法的时候就也引用了它一次（该引用是临时性的，调用结束后，自动解除引用。）
sys.getsizeof(object[, default])
	# 返回对象的大小
```





```python
import sys

def find_module(module):
    if module in sys.builtin_module_names:
        print(module, " 内置于=> ", "__builtin__")
    else:
        print(module, "模块位于=> ", __import__(module).__file__)


find_module('os')
find_module('sys')
find_module('time')
find_module('zlib')
find_module('string')

#----------
运行结果：
os 模块位于=>  C:\Python36\lib\os.py
sys  内置于=>  __builtin__
time  内置于=>  __builtin__
zlib  内置于=>  __builtin__
string 模块位于=>  C:\Python36\lib\string.py
```





### stdin、stdout

```python
s = input('Please input something！')


print('Please input something！',)  # 逗号表示不换行
s = sys.stdin.readline()[:-1]  # -1 可以抛弃输入流中的'\n' 换行符，自己琢磨一下为什么。
```



```python
>>> import sys
>>> s = sys.stdin.read()        # 使用ctrl+d结束输入
i like python
end



>>> s
'i like python\nend\n\n\n\n'
>>> sys.stdout.write(s)
i like python
end



21
```





#### 重定向

```python
__console__ = sys.stdout    # 保存控制台
# redirection start #       # 去干点别的，比如写到文件里

f_handler = open('out.log', 'w') 
sys.stdout = f_handler 
print('hello')
# 你无法在屏幕上看到“hello”
# 因为它被写到out.log文件里了

# redirection end           # 干完别的了，恢复原来的控制台
sys.stdout = __console__
```













## OS模块

```python
os.name	# 查看当前操作系统的名称。windows平台下返回‘nt’，Linux则返回‘posix’。
os.environ	# 获取系统环境变量

# 不能读取命令执行结果
os.system("explorer.exe %s" % open_url)

# popen可以读取命令执行结果
ret=os.popen("ipconfig").read()
```



```python

    
    
    
    
import os

curdir
	# 当前目录
sep
	# 即:"/"
pardir
	# os.chdir(os.pardir) 切换工作目录到上一级
	'''
    import os
    # 当前工作目录
    path = os.getcwd()
    print("当前工作目录: ", path)

    # 父目录
    parent = os.path.join(path, os.pardir)

    # 父目录
    print("\n父目录:", os.path.abspath(parent))	
	'''
getcwd()
	# 查看当前工作目录
chdir(Path)
	# 修改当前工作目录,切换到Path路径
listdir(path)
	# 返回指定的文件夹包含的文件或文件夹的名字的列表。
    # 这个列表以字母顺序。 它不包括 . 和 .. 即使它在文件夹中
    '''
    path = "./git-test"
    upath = unicode(path,'utf-8') # python3有没有这句话都无所谓
    dirs = os.listdir( upath )
    # 输出所有文件和文件夹
    for file in dirs:
    print (file)
    '''
makedirs(path, mode=0o777) 
	# 方法用于递归创建目录。嵌套目录
    # 第一个参数 path 只有一级，则 mkdir() 函数相同  
remove
 	# 用于删除指定路径的文件。如果指定的路径是一个目录，将抛出OSError
    '''
    import os, sys
    # 列出目录
    print ("目录为: %s" %os.listdir(os.getcwd()))
    # 移除
    os.remove("aa.txt")
    # 移除后列出目录
    print ("移除后 : %s" %os.listdir(os.getcwd()))
    '''
unlin(path)
	# 用于删除文件,如果文件是一个目录则返回一个错误
rmdir
    # 删除指定路径的目录。仅当这文件夹是空的才可以, 否则, 抛出OSError
    # # 不能删除非空目录
removedirs(path)
    # 用于递归删除目录。像rmdir(), 如果子文件夹成功删除, removedirs()才尝试它们的父文件夹
rename(src,dst)
	# 用于命名文件或目录
    # 如果重命名已存在，抛出OSError
renames(old, new)
	# 不是 单个 文件或目录，而是一串路径
	# 用于递归重命名目录或文件
    '''
    import os, sys
    print ("当前目录为: %s" %os.getcwd())
    # 列出目录
    print ("目录为: %s"%os.listdir(os.getcwd()))
    # 重命名 "aa1.txt"
    os.renames("aa1.txt","newdir/aanew.txt")
    print ("重命名成功。")
    # 列出重命名的文件 "aa1.txt"
    print ("目录为: %s" %os.listdir(os.getcwd()))
    '''
walk(top[, topdown=True[, onerror=None[, followlinks=False]]])
	# 创建一个生成器，用以生成所要查找的目录及其子目录下的所有文件
    '''
    import os
    for root, dirs, files in os.walk(".", topdown=False):
        for name in files:
            print(os.path.join(root, name))
        for name in dirs:
            print(os.path.join(root, name))
    '''
    
link(src, dst)
	# 创建一个已存在文件的拷贝是非常有用的
	# src -- 用于创建硬连接的源地址
	# dst -- 用于创建硬连接的目标地址
    '''
    import os, sys
    # 打开文件
    path = "/var/www/html/foo.txt"
    fd = os.open( path, os.O_RDWR|os.O_CREAT )
    # 关闭文件
    os.close( fd )

    # 创建以上文件的拷贝
    dst = "/tmp/foo.txt"
    os.link( path, dst)

    print ("创建硬链接成功!!")
    '''
symlink
readlink(path)
	# 用于返回软链接所指向的文件，可能返回绝对或相对路径
    '''
    #!/usr/bin/python3

    import os

    src = '/usr/bin/python'
    dst = '/tmp/python'

    # 创建软链接
    os.symlink(src, dst)

    # 使用软链接显示源链接
    path = os.readlink( dst )
    print (path)
    '''

     
stat(path)
	# 返回 文件信息
statvfs([path])
    # 返回包含文件描述符fd的文件的文件系统的信息
utime(path, times)
	# 方法用于设置指定路径文件最后的修改和访问时间

pipe
popen
	# 用于从一个命令打开一个管道
    '''
    import os, sys
    # 使用 mkdir 命令
    a = 'mkdir nwdir'
    b = os.popen(a,'r',1)
    '''
	


```



### os.path

```python
os.path.abspath(path)	返回绝对路径
	#  os.path.abspath(__file__) 
os.path.join(path1[, path2[, ...]])	把目录和文件名合成一个路径

os.path.basename(path)	返回文件名
os.path.dirname(path)	返回文件路径

os.path.exists(path)	路径存在则返回True,路径损坏返回False

os.path.split(path)	把路径分割成 dirname 和 basename，返回一个元组
os.path.splitext(path)	分割路径中的文件名与拓展名

os.path.getatime(path)	返回最近访问时间（浮点型秒数）
os.path.getmtime(path)	返回最近文件修改时间
os.path.getctime(path)	返回文件 path 创建时间
os.path.getsize(path)	返回文件大小，如果文件不存在就返回错误


os.path.isabs(path)	判断是否为绝对路径
os.path.isfile(path)	判断路径是否为文件
os.path.isdir(path)	判断路径是否为目录
os.path.islink(path)	判断路径是否为链接


os.path.expanduser(path)	把path中包含的"~"和"~user"转换成用户目录
os.path.expandvars(path)	根据环境变量的值替换path中包含的"$name"和"${name}"
```





### 案列

```python
import os
import os.path

ext_from = '.blv'
ext_to = '.flv'

read_file_dir = input(r'请输入要修改文件扩展名的路径：')

files = os.listdir(read_file_dir) # 列出当前目录下所有的文件

for filename in files:
    portion = os.path.splitext(filename) # 分离文件名字和后缀

    if portion[1] ==ext_from:  #检测扩展名
        newname = portion[0]+ext_to  #改新的新扩展名
        os.chdir(read_file_dir)  # 一定要切换到 当前目录
        os.rename(filename,newname)
        print(os.path.basename(filename)+' -> '+ os.path.basename(newname))
```









## 正则

```python
#  捕获组/具名捕获组/非捕获组
	捕获组引用/具名引用
    (?: re)	# 非捕获组
    
# 局部匹配模式
	(?imx) 	# 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
    		# 用法还不确定
    (?-imx)	# 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
    
    (?imx:re)		# 非捕获组 与 上述结合
    (?-imx:re)		# 非捕获组 与 上述结合
    
 # 特殊元字符
	\b 可以匹配的边界包括单词和特殊字符边界
    \d
    \w
    \s
    
 # 非贪婪模式

# 为了防止手动转义
	由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\t'，等价于 \\t )匹配相应的特殊字符
    
# flags参数: 多个标志可以通过按位 OR(|) 它们来指定
    re.I 忽略大小写
    re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境
    re.M 多行模式
    re.S 即为' . '并且包括换行符在内的任意字符（' . '不包括换行符）
    re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库
    re.X 为了增加可读性，忽略空格和' # '后面的注释
	

'''只找到第一个匹配'''
re.match(pattern, string, flags=0)
	# 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none
re.search(pattern, string, flags=0)
	# 扫描整个字符串并返回第一个成功的匹配
# 以上方法匹配成功都返回一个匹配的对象，否则返回None。
	group(num=0)	匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。
	groups()	返回一个包含所有小组字符串的元组，'从 1 到 所含的小组号'
    start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；
    end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；
    span([group]) 方法返回 (start(group), end(group))。    

    
    
    
'''找到所有匹配项'''
re.findall(pattern, string, flags=0)
# 或
pattern.findall(string[, pos[, endpos]])
	找到正则表达式所匹配的所有子串，并返回一个列表；
    如果有多个匹配模式，则返回元组列表； # 应该是当有组匹配时，返回的列表中的每一项元素是以元组;
    如果没有找到匹配的，则返回空列表
'''
import re
result = re.findall(r'(\w+)=(\d+)', 'set width=20 and height=10')
print(result)	# [('width', '20'), ('height', '10')]
'''
    
       
    
'''替换'''    
re.sub(pattern, repl, string, count=0, flags=0)
	# repl : 替换的字符串，也可为一个函数。
	# count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配
'''
import re
# 将匹配的数字乘于 2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)
 
s = 'A23G4HFD567'
print(re.sub(r'(?P<value>\d+)', double, s)) # 具名匹配
'''


'''正则表达式编译'''
re.compile(pattern[, flags])
'''
>>>import re
>>> pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I)   # re.I 表示忽略大小写
>>> m = pattern.match('Hello World Wide Web')
>>> print( m )                            # 匹配成功，返回一个 Match 对象
<_sre.SRE_Match object at 0x10bea83e8>
>>> m.group(0)                            # 返回匹配成功的整个子串
'Hello World'
>>> m.span(0)                             # 返回匹配成功的整个子串的索引
(0, 11)
>>> m.group(1)                            # 返回第一个分组匹配成功的子串
'Hello'
>>> m.span(1)                             # 返回第一个分组匹配成功的子串的索引
(0, 5)
>>> m.group(2)                            # 返回第二个分组匹配成功的子串
'World'
>>> m.span(2)                             # 返回第二个分组匹配成功的子串索引
(6, 11)
>>> m.groups()                            # 等价于 (m.group(1), m.group(2), ...)
('Hello', 'World')
>>> m.group(3)                            # 不存在第三个分组
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: no such group
'''


'''迭代器'''
re.finditer(pattern, string, flags=0)
	在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个'迭代器'返回
'''
import re
it = re.finditer(r"\d+","12a32bc43jf3") 
for match in it: 
    print (match.group() )
'''



'''分割字符串'''
re.split(pattern, string[, maxsplit=0, flags=0])
'''
>>>import re
>>> re.split('\W+', 'runoob, runoob, runoob.')
['runoob', 'runoob', 'runoob', '']

>>> re.split('(\W+)', ' runoob, runoob, runoob.')  # 注意这里的区别
['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', '']

>>> re.split('\W+', ' runoob, runoob, runoob.', 1) 
['', 'runoob, runoob, runoob.']
 
>>> re.split('a*', 'hello world')   # 对于一个找不到匹配的字符串而言，split 不会对其作出分割
['hello world']
'''



```







